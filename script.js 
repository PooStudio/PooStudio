window.addEventListener("load", () => {
    const intro = document.getElementById("intro");
    document.getElementById("year").textContent = new Date().getFullYear();
    const starsContainer = document.getElementById("starsContainer");
    let idleTimeout;
    const idleTime = 30000;
    function createStar() {
        const star = document.createElement("div");
        star.classList.add("star");
        star.style.left = `${Math.random() * 100}vw`;
        star.style.animationDuration = `${Math.random() * 2 + 1}s`;
        starsContainer.appendChild(star);
        // Remove star after animation
        setTimeout(() => {
            star.remove();
        }, 3000); // Match animation duration
    }
    function startStars() {
        starsContainer.style.display = "block";
        const interval = setInterval(createStar, 200);
        return interval;
    }
    function stopStars(interval) {
        clearInterval(interval);
        starsContainer.innerHTML = "";
        starsContainer.style.display = "none";
    }
    let starsInterval;
    function resetIdleTimer() {
        clearTimeout(idleTimeout);
        if (starsInterval) {
            stopStars(starsInterval);
            starsInterval = null;
        }
        idleTimeout = setTimeout(() => {
            starsInterval = startStars();
        }, idleTime);
    }
    window.addEventListener("mousemove", resetIdleTimer);
    window.addEventListener("keydown", resetIdleTimer);
    window.addEventListener("scroll", resetIdleTimer);
    window.addEventListener("touchstart", resetIdleTimer); // For mobile
    resetIdleTimer();
    // Smooth fade on scroll
    window.addEventListener('scroll', () => {
        if (intro) {
            const scrollY = window.pageYOffset;
            const vh = window.innerHeight;
            let opacity = 1 - (scrollY / (vh * 0.8)); // Fade over 80% of viewport height
            opacity = Math.max(0, Math.min(1, opacity));
            intro.style.opacity = opacity;
            if (opacity <= 0) {
                intro.remove();
            }
        }
    });

    // Three.js setup for intro
    const canvas = document.getElementById('intro-canvas');
    const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    const ambientLight = new THREE.AmbientLight(0x404040, 1);
    scene.add(ambientLight);

    const pointLight = new THREE.PointLight(0xffffff, 2, 100);
    pointLight.position.set(0, 0, 10);
    scene.add(pointLight);

    // Outer rune
    const outerGeometry = new THREE.TorusGeometry(3, 0.05, 16, 100);
    const outerMaterial = new THREE.MeshPhongMaterial({ color: 0xcfa15a, transparent: true, opacity: 0.15, shininess: 100 });
    const outer = new THREE.Mesh(outerGeometry, outerMaterial);
    scene.add(outer);

    // Middle rune
    const middleGeometry = new THREE.TorusGeometry(2.5, 0.05, 16, 100);
    const middleMaterial = new THREE.MeshPhongMaterial({ color: 0xcfa15a, transparent: true, opacity: 0.2, shininess: 100 });
    const middle = new THREE.Mesh(middleGeometry, middleMaterial);
    scene.add(middle);

    // Inner rune
    const innerGeometry = new THREE.TorusGeometry(2, 0.05, 16, 100);
    const innerMaterial = new THREE.MeshPhongMaterial({ color: 0xcfa15a, transparent: true, opacity: 0.1, shininess: 100 });
    const inner = new THREE.Mesh(innerGeometry, innerMaterial);
    scene.add(inner);

    // Particles for unreal effect
    const particleCount = 1000;
    const particles = new THREE.BufferGeometry();
    const posArray = new Float32Array(particleCount * 3);
    for (let i = 0; i < particleCount * 3; i++) {
        posArray[i] = (Math.random() - 0.5) * 10;
    }
    particles.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    const particleMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.01, blending: THREE.AdditiveBlending });
    const particleMesh = new THREE.Points(particles, particleMaterial);
    scene.add(particleMesh);

    function animate() {
        requestAnimationFrame(animate);

        outer.rotation.x += 0.001;
        outer.rotation.y += 0.001;

        middle.rotation.x += 0.0005;
        middle.rotation.y += 0.0005;

        inner.rotation.x -= 0.001;
        inner.rotation.y -= 0.001;

        particleMesh.rotation.y += 0.0001;

        renderer.render(scene, camera);
    }

    animate();

    // Resize handler
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
});