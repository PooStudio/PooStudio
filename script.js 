window.addEventListener("load", () => {
    document.getElementById("year").textContent = new Date().getFullYear();

    // Three.js Particle Brain Network
    const container = document.getElementById('three-container');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    const particlesCount = 3000;
    const positions = new Float32Array(particlesCount * 3);
    const colors = new Float32Array(particlesCount * 3);

    for (let i = 0; i < particlesCount * 3; i += 3) {
        const radius = 15 + Math.random() * 20; // Brain-like cluster
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        positions[i] = radius * Math.sin(phi) * Math.cos(theta);
        positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta) - 5; // Slight offset for brain shape
        positions[i + 2] = radius * Math.cos(phi);

        const color = new THREE.Color(0xffffff);
        color.setHSL(0.1 + Math.random() * 0.1, 0.5, 0.7);
        colors[i] = color.r;
        colors[i + 1] = color.g;
        colors[i + 2] = color.b;
    }

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({ size: 0.1, vertexColors: true });
    const points = new THREE.Points(geometry, material);
    scene.add(points);

    // Add lines for plexus effect
    const linesGeometry = new THREE.BufferGeometry();
    const lines = [];
    for (let i = 0; i < particlesCount; i++) {
        for (let j = i + 1; j < particlesCount; j++) {
            const dist = positions[i*3] - positions[j*3] ** 2 + ... // simplified, connect if close
            if (dist < 20) lines.push(...positions.slice(i*3, i*3+3), ...positions.slice(j*3, j*3+3));
        }
    }
    linesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(lines, 3));
    const linesMaterial = new THREE.LineBasicMaterial({ color: 0x333333, opacity: 0.2, transparent: true });
    const linesMesh = new THREE.LineSegments(linesGeometry, linesMaterial);
    scene.add(linesMesh);

    camera.position.z = 60;

    // Mouse interaction
    const mouse = new THREE.Vector2();
    window.addEventListener('mousemove', (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    });

    function animate() {
        requestAnimationFrame(animate);
        points.rotation.y += 0.0005;
        linesMesh.rotation.y += 0.0005;
        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });


});